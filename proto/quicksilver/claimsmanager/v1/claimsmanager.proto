syntax = "proto3";
package quicksilver.claimsmanager.v1;

import "cosmos_proto/cosmos.proto";
import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";
import "tendermint/crypto/proof.proto";

option go_package = "github.com/quicksilver-zone/quicksilver/x/claimsmanager/types";

enum ClaimType {
  option (gogoproto.goproto_enum_prefix) = false;

  // Undefined action (per protobuf spec)
  ClaimTypeUndefined = 0;
  ClaimTypeLiquidToken = 1;
  ClaimTypeOsmosisPool = 2;
  ClaimTypeCrescentPool = 3 [deprecated = true];
  ClaimTypeSifchainPool = 4 [deprecated = true];
  ClaimTypeUmeeToken = 5;
  ClaimTypeOsmosisCLPool = 6;
}

// Params holds parameters for the claimsmanager module.
message Params {
  option (gogoproto.goproto_getters) = false;
  option (gogoproto.goproto_stringer) = false;

  bool claims_enabled = 1;
}

message ClaimableEvent {
  string event_module = 1; // module name doing the claim, “govbyproxy”, “participationrewards”, “airdrop” (types.ModuleName)
  string event_name = 2; // “epoch”, “proposal/cosmoshub-4/764”, “airdrop/cosmoshub-4” // todo set as id
  map<string, int64> heights = 3; // heights across each chain for this event - when initialised create with the chainID and 0, for each relevant zone. For all zones, use all zones we have a connectionData for; airdrop proofs will require _latest_ (pool contents, etc.) to be submitted by the user.
  google.protobuf.Timestamp max_claim_time = 4 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];  // when can we claim until? (Proposal end vote time, next epoch boundary, airdrop end)
}

// trigger self consensus state on every claimable event
// icq query fired off every time

// Claim define the users claim for holding assets within a given zone.
message Claim {
  option (gogoproto.goproto_getters) = false;

  string user_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
  string chain_id = 2;
  ClaimType module = 3;
  string source_chain_id = 4;
  uint64 _amount = 5 [deprecated = true];
  string amount = 6 [
    (cosmos_proto.scalar) = "cosmos.Int",
    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.nullable) = false
  ];
}

// Proof defines a type used to cryptographically prove a claim.
message Proof {
  option (gogoproto.equal) = false;
  option (gogoproto.goproto_getters) = false;

  bytes key = 1 [json_name = "key"];
  bytes data = 2 [json_name = "data"];
  tendermint.crypto.ProofOps proof_ops = 3 [json_name = "proof_ops"];
  int64 height = 4 [json_name = "height"];
  string proof_type = 5 [json_name = "proof_type"];
}

message KeyedProtocolData {
  string key = 1;
  ProtocolData protocol_data = 2;
}

// Protocol Data is an arbitrary data type held against a given zone for the
// determination of rewards.
message ProtocolData {
  string type = 1;
  bytes data = 2 [(gogoproto.casttype) = "encoding/json.RawMessage"];
}

enum ProtocolDataType {
  option (gogoproto.goproto_enum_prefix) = false;

  // Undefined action (per protobuf spec)
  ProtocolDataTypeUndefined = 0;
  ProtocolDataTypeConnection = 1;
  ProtocolDataTypeOsmosisParams = 2;
  ProtocolDataTypeLiquidToken = 3;
  ProtocolDataTypeOsmosisPool = 4;
  ProtocolDataTypeCrescentPool = 5 [deprecated = true];
  ProtocolDataTypeSifchainPool = 6 [deprecated = true];
  ProtocolDataTypeUmeeParams = 7;
  ProtocolDataTypeUmeeReserves = 8;
  ProtocolDataTypeUmeeInterestScalar = 9;
  ProtocolDataTypeUmeeTotalBorrows = 10;
  ProtocolDataTypeUmeeUTokenSupply = 11;
  ProtocolDataTypeUmeeLeverageModuleBalance = 12;
  ProtocolDataTypeCrescentParams = 13 [deprecated = true];
  ProtocolDataTypeCrescentReserveAddressBalance = 14 [deprecated = true];
  ProtocolDataTypeCrescentPoolCoinSupply = 15 [deprecated = true];
  ProtocolDataTypeOsmosisCLPool = 16;
}
